[
    {
        "instruction": "Explain how the @topic and @key annotations work in OpenDDS IDL files and why they're important for DDS communication.",
        "input": "File: examples/DCPS/IntroductionToOpenDDS/StockQuoter.idl\n\n```idl\nmodule StockQuoter {\n\n  typedef unsigned long long TimeT;\n\n  @topic\n  struct Quote {\n    @key string ticker;\n    string exchange;\n    string full_name;\n    double value;\n    TimeT timestamp;\n  };\n\n  enum ExchangeEventType { TRADING_OPENED,\n                           TRADING_CLOSED,\n                           TRADING_SUSPENDED,\n                           TRADING_RESUMED };\n  @topic\n  struct ExchangeEvent {\n    @key string exchange;\n    ExchangeEventType event;\n    TimeT timestamp;\n  };\n};\n```",
        "output": "The `@topic` and `@key` annotations in OpenDDS IDL serve critical roles in DDS communication:\n\n**@topic annotation:**\n- Marks a struct or union as a type that can be used for DDS topics\n- Required for any type you want to publish/subscribe to\n- Triggers OpenDDS code generation for TypeSupport, DataWriter, and DataReader classes\n- In this example, both `Quote` and `ExchangeEvent` can be used as topic types\n\n**@key annotation:**\n- Identifies one or more fields that define DDS Instances within a topic\n- Samples with the same key value belong to the same Instance\n- Different key values represent different Instances\n- Used for:\n  - Instance lifecycle management (register, dispose, unregister)\n  - QoS policies like HISTORY that operate per-instance\n  - Filtering and content-based subscriptions\n\n**In this example:**\n- `Quote` uses `ticker` as the key, so each stock symbol (\"SPY\", \"MDY\") is a separate Instance\n- `ExchangeEvent` uses `exchange` as the key, so events are grouped by exchange name\n- With default QoS, new samples replace previous values for the same Instance\n\n**Why this matters:**\nWhen the publisher calls `register_instance()` with a `Quote` having `ticker=\"SPY\"`, it creates an Instance. All subsequent writes with `ticker=\"SPY\"` update that same Instance, enabling proper instance-based history management and lifecycle tracking.",
        "metadata": {
            "task_type": "code_explanation",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/StockQuoter.idl"
            ],
            "difficulty": "easy"
        }
    },
    {
        "instruction": "I'm implementing a DataReaderListener in OpenDDS. Explain the on_data_available callback pattern and how to properly read samples.",
        "input": "File: examples/DCPS/IntroductionToOpenDDS/QuoteDataReaderListenerImpl.cpp\n\n```cpp\nvoid QuoteDataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader)\n{\n  try {\n    StockQuoter::QuoteDataReader_var quote_dr\n      = StockQuoter::QuoteDataReader::_narrow(reader);\n    if (CORBA::is_nil (quote_dr.in ())) {\n      cerr << \"QuoteDataReaderListenerImpl::on_data_available: _narrow failed.\" << endl;\n      ACE_OS::exit(1);\n    }\n\n    int count = 0;\n    while(true) {\n      StockQuoter::Quote quote;\n      DDS::SampleInfo si ;\n      DDS::ReturnCode_t status = quote_dr->take_next_sample(quote, si) ;\n\n      if (status == DDS::RETCODE_OK && si.valid_data) {\n        ++count;\n        cout << \"Quote: ticker    = \" << quote.ticker.in()    << endl;\n        // ... process data\n      } else if (status == DDS::RETCODE_NO_DATA) {\n        cerr << \"INFO: reading complete after \" << count << \" samples.\" << endl;\n        break;\n      } else {\n        cerr << \"ERROR: read Quote: Error: \" <<  status << endl;\n      }\n    }\n  } catch (CORBA::Exception& e) {\n    cerr << \"Exception caught in read:\" << endl << e << endl;\n    ACE_OS::exit(1);\n  }\n}\n```",
        "output": "The `on_data_available` callback is the primary mechanism for receiving data in OpenDDS. Here's the pattern breakdown:\n\n**1. Narrow the DataReader:**\n```cpp\nStockQuoter::QuoteDataReader_var quote_dr\n  = StockQuoter::QuoteDataReader::_narrow(reader);\n```\nThe callback receives a generic `DDS::DataReader_ptr`. You must narrow it to your type-specific DataReader to access typed read/take operations.\n\n**2. Loop to drain all available samples:**\n```cpp\nwhile(true) {\n  DDS::ReturnCode_t status = quote_dr->take_next_sample(quote, si);\n  if (status == DDS::RETCODE_NO_DATA) break;\n  // process...\n}\n```\nMultiple samples may be available when the callback fires. Always loop until `RETCODE_NO_DATA`.\n\n**3. Check SampleInfo.valid_data:**\n```cpp\nif (status == DDS::RETCODE_OK && si.valid_data) {\n```\n`valid_data` is `false` for dispose/unregister notifications where no actual data payload exists. Only access `quote` fields when `valid_data` is `true`.\n\n**4. take vs read:**\n- `take_next_sample()` removes the sample from the DataReader's cache\n- `read_next_sample()` leaves the sample (useful for KEEP_ALL history)\n\n**5. SampleInfo fields:**\n- `sample_rank`: position in instance history (0 = most recent)\n- `instance_handle`: identifies the DDS Instance\n- `publication_handle`: identifies the DataWriter that sent it\n- `source_timestamp`: when the sample was written\n\n**Best practice:** Wrap the entire callback in try-catch since exceptions here can crash the middleware thread.",
        "metadata": {
            "task_type": "code_explanation",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/QuoteDataReaderListenerImpl.cpp"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "Show me how to create a basic OpenDDS publisher that registers types, creates topics, and writes data.",
        "input": "I need to publish stock quote data using the StockQuoter.idl types. What's the proper sequence of OpenDDS API calls?",
        "output": "Here's the complete publisher pattern from the IntroductionToOpenDDS example:\n\n**1. Initialize and create DomainParticipant:**\n```cpp\n#include \"StockQuoterTypeSupportImpl.h\"\n#include <dds/DCPS/Service_Participant.h>\n#include <dds/DCPS/Marked_Default_Qos.h>\n\nDDS::DomainParticipantFactory_var dpf = TheParticipantFactoryWithArgs(argc, argv);\n\nDDS::DomainParticipant_var participant = dpf->create_participant(\n  QUOTER_DOMAIN_ID,           // Domain ID (e.g., 1066)\n  PARTICIPANT_QOS_DEFAULT,\n  DDS::DomainParticipantListener::_nil(),\n  OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n```\n\n**2. Create Publisher:**\n```cpp\nDDS::Publisher_var pub = participant->create_publisher(\n  PUBLISHER_QOS_DEFAULT,\n  DDS::PublisherListener::_nil(),\n  OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n```\n\n**3. Register the type:**\n```cpp\nStockQuoter::QuoteTypeSupport_var quote_servant\n  = new StockQuoter::QuoteTypeSupportImpl();\nquote_servant->register_type(participant.in(), \"Quote Type\");\n```\n\n**4. Create Topic:**\n```cpp\nDDS::Topic_var quote_topic = participant->create_topic(\n  \"Stock Quotes\",        // Topic name\n  \"Quote Type\",          // Registered type name\n  TOPIC_QOS_DEFAULT,\n  DDS::TopicListener::_nil(),\n  OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n```\n\n**5. Create DataWriter:**\n```cpp\nDDS::DataWriter_var quote_base_dw = pub->create_datawriter(\n  quote_topic.in(),\n  DATAWRITER_QOS_DEFAULT,\n  DDS::DataWriterListener::_nil(),\n  OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n\nStockQuoter::QuoteDataWriter_var quote_dw\n  = StockQuoter::QuoteDataWriter::_narrow(quote_base_dw.in());\n```\n\n**6. Register instance and write:**\n```cpp\nStockQuoter::Quote spy;\nspy.ticker = CORBA::string_dup(\"SPY\");\nDDS::InstanceHandle_t spy_handle = quote_dw->register_instance(spy);\n\nspy.exchange = STOCK_EXCHANGE_NAME;\nspy.full_name = CORBA::string_dup(\"S&P Depository Receipts\");\nspy.value = 1200.0;\nspy.timestamp = get_timestamp();\n\nDDS::ReturnCode_t ret = quote_dw->write(spy, spy_handle);\nif (ret != DDS::RETCODE_OK) {\n  ACE_ERROR((LM_ERROR, \"ERROR: write returned %d.\\n\", ret));\n}\n```\n\n**7. Cleanup:**\n```cpp\nparticipant->delete_contained_entities();\ndpf->delete_participant(participant.in());\nTheServiceParticipant->shutdown();\n```\n\n**Key points:**\n- `register_instance()` is optional but improves performance for repeated writes\n- Always check return codes from `write()`\n- Call `shutdown()` on `TheServiceParticipant` before exiting",
        "metadata": {
            "task_type": "api_usage",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/publisher.cpp",
                "examples/DCPS/IntroductionToOpenDDS/StockQuoter.idl"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "The DataReaderListener callback is not receiving any data. How do I debug association issues between my publisher and subscriber?",
        "input": "My subscriber's on_data_available is never called even though the publisher is running. Both are using domain ID 111 and the same topic name.",
        "output": "Here's a systematic debugging approach for OpenDDS association failures:\n\n**1. Enable Debug Logging:**\nIn your configuration file or via command line:\n```ini\n[common]\nDCPSDebugLevel=5\n```\nOr: `-DCPSDebugLevel 5`\n\nThis reveals discovery and association events.\n\n**2. Verify Domain ID Match:**\nBoth publisher and subscriber must use the identical domain ID:\n```cpp\n// Publisher\nparticipant = dpf->create_participant(111, ...);\n// Subscriber - must also be 111\nparticipant = dpf->create_participant(111, ...);\n```\n\n**3. Verify Type Name and Topic Name Match Exactly:**\n```cpp\n// Publisher\nservant->register_type(participant.in(), \"MyType\");  // Type name\nparticipant->create_topic(\"MyTopic\", \"MyType\", ...); // Topic name, type name\n\n// Subscriber must use identical strings\nservant->register_type(participant.in(), \"MyType\");\nparticipant->create_topic(\"MyTopic\", \"MyType\", ...);\n```\n\n**4. Check QoS Compatibility:**\nCommon incompatibilities:\n- Reliability: Writer offers BEST_EFFORT, Reader requests RELIABLE\n- Durability: Writer offers VOLATILE, Reader requests TRANSIENT_LOCAL\n\nAdd `on_requested_incompatible_qos` listener to detect:\n```cpp\nvoid MyListener::on_requested_incompatible_qos(\n    DDS::DataReader_ptr,\n    const DDS::RequestedIncompatibleQosStatus& status) {\n  cerr << \"Incompatible QoS! Policy ID: \" << status.last_policy_id << endl;\n}\n```\n\n**5. Verify Transport Configuration:**\nCheck that both use compatible transports:\n```ini\n[config/config1]\ntransports=tcp1\n\n[transport/tcp1]\ntransport_type=tcp\n```\nBoth processes need matching transport configurations.\n\n**6. Check for Discovery Issues:**\nFor InfoRepo discovery:\n```ini\n[common]\nDCPSInfoRepo=corbaloc::localhost:12345/DCPSInfoRepo\n```\nEnsure InfoRepo is running and accessible to both.\n\nFor RTPS discovery (peer-to-peer):\n```ini\n[common]\nDCPSDefaultDiscovery=DEFAULT_RTPS\n```\n\n**7. Wait for Association:**\nIn Writer.cpp pattern - wait for matched subscriptions:\n```cpp\nDDS::InstanceHandleSeq handles;\nwhile (true) {\n  writer_->get_matched_subscriptions(handles);\n  if (handles.length() > 0) break;\n  ACE_OS::sleep(ACE_Time_Value(0, 200000));\n}\n```\n\n**8. Verify Listener is Attached:**\n```cpp\nDDS::DataReader_var dr = sub->create_datareader(\n  topic.in(),\n  dr_qos,\n  listener.in(),  // Must not be nil!\n  OpenDDS::DCPS::DEFAULT_STATUS_MASK);  // Must include DATA_AVAILABLE\n```",
        "metadata": {
            "task_type": "debugging",
            "files": [
                "examples/DCPS/Messenger_Imr/Writer.cpp",
                "examples/DCPS/IntroductionToOpenDDS/dds_tcp_conf.ini"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "Fix the bug in this on_data_available implementation that can cause a crash when receiving dispose notifications.",
        "input": "File: buggy_listener.cpp\n\n```cpp\nvoid MyDataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader)\n{\n  Messenger::MessageDataReader_var message_dr = \n    Messenger::MessageDataReader::_narrow(reader);\n  \n  Messenger::Message message;\n  DDS::SampleInfo si;\n  DDS::ReturnCode_t status = message_dr->take_next_sample(message, si);\n\n  if (status == DDS::RETCODE_OK) {\n    // Bug: accessing message fields without checking valid_data\n    cout << \"Received message from: \" << message.from.in() << endl;\n    cout << \"Subject: \" << message.subject.in() << endl;\n    cout << \"Count: \" << message.count << endl;\n    process_message(message);\n  }\n}\n```",
        "output": "**The Bug:**\nThe code accesses `message` fields without checking `si.valid_data`. When a DataWriter disposes or unregisters an instance, `on_data_available` is called but `valid_data` is `false` and the `message` struct contains uninitialized/garbage data. Accessing `message.from.in()` on invalid data causes undefined behavior (likely crash).\n\n**Fixed Code:**\n```cpp\nvoid MyDataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader)\n{\n  try {\n    Messenger::MessageDataReader_var message_dr = \n      Messenger::MessageDataReader::_narrow(reader);\n    \n    if (CORBA::is_nil(message_dr.in())) {\n      ACE_ERROR((LM_ERROR, \"on_data_available: _narrow failed\\n\"));\n      return;\n    }\n\n    Messenger::Message message;\n    DDS::SampleInfo si;\n    \n    // Loop to drain all available samples\n    while (true) {\n      DDS::ReturnCode_t status = message_dr->take_next_sample(message, si);\n      \n      if (status == DDS::RETCODE_NO_DATA) {\n        break;  // No more samples\n      }\n      \n      if (status != DDS::RETCODE_OK) {\n        ACE_ERROR((LM_ERROR, \"take_next_sample error: %d\\n\", status));\n        break;\n      }\n\n      // CRITICAL: Check valid_data before accessing message fields\n      if (si.valid_data) {\n        cout << \"Received message from: \" << message.from.in() << endl;\n        cout << \"Subject: \" << message.subject.in() << endl;\n        cout << \"Count: \" << message.count << endl;\n        process_message(message);\n      } else {\n        // Handle instance state change (dispose/unregister)\n        if (si.instance_state == DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE) {\n          cout << \"Instance disposed by writer\" << endl;\n        } else if (si.instance_state == DDS::NOT_ALIVE_NO_WRITERS_INSTANCE_STATE) {\n          cout << \"Instance has no writers\" << endl;\n        }\n      }\n    }\n  } catch (CORBA::Exception& e) {\n    ACE_ERROR((LM_ERROR, \"Exception in on_data_available: %C\\n\", e._info().c_str()));\n  }\n}\n```\n\n**Key Fixes:**\n1. **Check `si.valid_data`** before accessing any message fields\n2. **Add null check** after `_narrow()` for defensive coding\n3. **Loop until `RETCODE_NO_DATA`** - multiple samples may be available\n4. **Wrap in try-catch** - exceptions in listener can crash middleware\n5. **Handle instance state changes** when `valid_data` is false\n\n**When `valid_data` is false:**\n- `instance_state` indicates why (disposed, no writers)\n- `instance_handle` identifies which instance\n- The data fields are NOT valid and must not be accessed",
        "metadata": {
            "task_type": "bug_fixing",
            "files": [
                "examples/DCPS/Messenger_Imr/DataReaderListener.cpp",
                "examples/DCPS/IntroductionToOpenDDS/QuoteDataReaderListenerImpl.cpp"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "How do I configure OpenDDS to use TCP transport with a specific configuration file?",
        "input": "I want to set up TCP transport for my OpenDDS application. What configuration file format should I use and how do I reference it?",
        "output": "Here's how to configure OpenDDS TCP transport:\n\n**1. Create configuration file (e.g., `dds_tcp_conf.ini`):**\n```ini\n# Global settings\n[common]\nDCPSDebugLevel=0\nDCPSInfoRepo=corbaloc::localhost:12345/DCPSInfoRepo\nDCPSGlobalTransportConfig=config1\n\n# Transport configuration - groups transport instances\n[config/config1]\ntransports=tcp1\n\n# TCP transport instance with default settings\n[transport/tcp1]\ntransport_type=tcp\n```\n\n**2. Reference the config file at runtime:**\n\n**Option A: Command-line argument:**\n```bash\n./publisher -DCPSConfigFile dds_tcp_conf.ini\n```\n\n**Option B: Environment variable:**\n```bash\nexport OPENDDS_DCPS_CONFIG_FILE=dds_tcp_conf.ini\n./publisher\n```\n\n**3. Ensure transport is linked in your code:**\n```cpp\n// Include static transport initializer\n#include \"dds/DCPS/StaticIncludes.h\"\n// Or link against OpenDDS_Tcp library\n```\n\n**4. MPC project file (for build system):**\n```mpc\nproject(*Publisher) : dcpsexe, dcps_tcp {\n  // dcps_tcp base project links the TCP transport\n  ...\n}\n```\n\n**Advanced TCP configuration options:**\n```ini\n[transport/tcp1]\ntransport_type=tcp\nlocal_address=192.168.1.100:9000  # Bind address\npub_address=192.168.1.100:9000    # Advertised address (for NAT)\nconn_retry_initial_delay=500      # ms before first reconnect attempt\nconn_retry_backoff_multiplier=2.0 # Backoff factor for retries\nconn_retry_attempts=3             # Max reconnection attempts\nmax_output_pause_period=0         # 0 = block until sent\npassive_reconnect_duration=2000   # ms to wait for reconnect\n```\n\n**For RTPS (peer-to-peer, no InfoRepo):**\n```ini\n[common]\nDCPSDefaultDiscovery=DEFAULT_RTPS\nDCPSGlobalTransportConfig=config1\n\n[config/config1]\ntransports=rtps_transport\n\n[transport/rtps_transport]\ntransport_type=rtps_udp\n```\n\n**Configuration hierarchy:**\n1. `[common]` - Process-wide settings\n2. `[config/name]` - Named transport configuration (groups instances)\n3. `[transport/name]` - Individual transport instance settings\n\nThe `DCPSGlobalTransportConfig` in `[common]` sets the default config for all entities unless overridden per-entity.",
        "metadata": {
            "task_type": "build_configuration",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/dds_tcp_conf.ini",
                "examples/DCPS/IntroductionToOpenDDS/StockQuoter.mpc"
            ],
            "difficulty": "easy"
        }
    },
    {
        "instruction": "Explain the MPC project file structure for building an OpenDDS application with custom IDL types.",
        "input": "File: examples/DCPS/IntroductionToOpenDDS/StockQuoter.mpc\n\n```mpc\nproject(*Common) : dcps_idl_only_lib {\n  sharedname     = StockQuoterCommon\n  dynamicflags   = STOCKQUOTERCOMMON_BUILD_DLL\n  requires += tao_orbsvcs\n  requires += no_opendds_safety_profile\n  after    += Svc_Utils\n  includes      += $(TAO_ROOT)/orbsvcs\n  idlflags      += -I$(TAO_ROOT)/orbsvcs \\\n                   -Wb,export_macro=StockQuoterCommon_Export \\\n                   -Wb,export_include=StockQuoterCommon_Export.h\n  dcps_ts_flags += -Wb,export_macro=StockQuoterCommon_Export\n\n  TypeSupport_Files {\n    StockQuoter.idl\n  }\n\n  IDL_Files {\n    StockQuoterTypeSupport.idl\n    StockQuoter.idl\n  }\n}\n\nproject(*Publisher) : dcpsexe, dcps_tcp, svc_utils {\n  after    += *Common\n  exename   = publisher\n  includes += $(TAO_ROOT)/orbsvcs\n  libs     += StockQuoterCommon\n\n  Source_Files {\n    publisher.cpp\n  }\n}\n```",
        "output": "This MPC file defines a multi-project build for an OpenDDS application. Here's the breakdown:\n\n**Project 1: `*Common` - Shared IDL Library**\n\n```mpc\nproject(*Common) : dcps_idl_only_lib {\n```\n- `*Common` - Project name (asterisk inherits from workspace name)\n- `dcps_idl_only_lib` - Base project for IDL-only shared libraries\n\n```mpc\n  sharedname     = StockQuoterCommon\n  dynamicflags   = STOCKQUOTERCOMMON_BUILD_DLL\n```\n- Creates `StockQuoterCommon.dll` (Windows) or `libStockQuoterCommon.so` (Linux)\n- `dynamicflags` defines the DLL export macro during compilation\n\n```mpc\n  idlflags      += -Wb,export_macro=StockQuoterCommon_Export \\\n                   -Wb,export_include=StockQuoterCommon_Export.h\n  dcps_ts_flags += -Wb,export_macro=StockQuoterCommon_Export\n```\n- Configures IDL compilers to use proper DLL export macros\n- `idlflags` for TAO IDL compiler\n- `dcps_ts_flags` for OpenDDS IDL compiler\n\n```mpc\n  TypeSupport_Files {\n    StockQuoter.idl\n  }\n```\n- **Key section**: Lists IDL files for OpenDDS type support generation\n- Generates: `StockQuoterTypeSupportImpl.h/.cpp`, `StockQuoterTypeSupport.idl`\n\n```mpc\n  IDL_Files {\n    StockQuoterTypeSupport.idl\n    StockQuoter.idl\n  }\n```\n- IDL files processed by TAO IDL compiler\n- Generates: `*C.h`, `*C.cpp`, `*S.h`, `*S.cpp`\n\n**Project 2: `*Publisher` - Executable**\n\n```mpc\nproject(*Publisher) : dcpsexe, dcps_tcp, svc_utils {\n```\n- `dcpsexe` - Base project for OpenDDS executables\n- `dcps_tcp` - Links TCP transport\n- `svc_utils` - TAO ORB services utilities\n\n```mpc\n  after    += *Common\n  libs     += StockQuoterCommon\n```\n- Build dependency: compile `*Common` first\n- Link against the generated shared library\n\n**To build:**\n```bash\n# Generate makefiles/solution\n$ACE_ROOT/bin/mwc.pl -type gnuace  # Linux\n%ACE_ROOT%\\bin\\mwc.pl -type vs2019  # Windows\n\n# Build\nmake  # Linux\nmsbuild StockQuoter.sln  # Windows\n```\n\n**Common base projects:**\n- `dcps` - Core OpenDDS\n- `dcps_tcp` - TCP transport\n- `dcps_udp` - UDP transport  \n- `dcps_rtps` - RTPS transport\n- `dcpsexe` - Executable with OpenDDS\n- `dcps_idl_only_lib` - IDL library only",
        "metadata": {
            "task_type": "build_configuration",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/StockQuoter.mpc"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "Refactor this polling-based subscription termination to use a proper DDS condition with WaitSet.",
        "input": "File: examples/DCPS/IntroductionToOpenDDS/subscriber.cpp (current approach)\n\n```cpp\n// Wait for events from the Publisher; shut down when \"close\" received\ncout << \"Subscriber: waiting for events\" << endl;\nwhile ( ! listener_servant->is_exchange_closed_received() ) {\n  ACE_OS::sleep(1);\n}\ncout << \"Received CLOSED event from publisher; exiting...\" << endl;\n```\n\nThe subscriber currently polls a flag in the listener every second. This wastes CPU and has up to 1 second latency.",
        "output": "Here's a refactored version using DDS GuardCondition with WaitSet for efficient, low-latency waiting:\n\n**1. Add GuardCondition to the listener:**\n```cpp\n// ExchangeEventDataReaderListenerImpl.h\nclass ExchangeEventDataReaderListenerImpl \n  : public virtual OpenDDS::DCPS::LocalObject<DDS::DataReaderListener> {\npublic:\n  ExchangeEventDataReaderListenerImpl();\n  \n  // Existing methods...\n  void on_data_available(DDS::DataReader_ptr reader) override;\n  \n  // Replace is_exchange_closed_received() with condition\n  DDS::GuardCondition_ptr get_close_condition() { return close_condition_.in(); }\n\nprivate:\n  DDS::GuardCondition_var close_condition_;\n};\n```\n\n**2. Initialize and trigger in listener implementation:**\n```cpp\n// ExchangeEventDataReaderListenerImpl.cpp\nExchangeEventDataReaderListenerImpl::ExchangeEventDataReaderListenerImpl()\n  : close_condition_(new DDS::GuardCondition())\n{\n}\n\nvoid ExchangeEventDataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader)\n{\n  // ... existing narrow and take code ...\n  \n  if (status == DDS::RETCODE_OK && si.valid_data) {\n    if (exchange_event.event == StockQuoter::TRADING_CLOSED) {\n      // Signal the condition instead of setting a flag\n      close_condition_->set_trigger_value(true);\n    }\n  }\n}\n```\n\n**3. Use WaitSet in main subscriber code:**\n```cpp\n// subscriber.cpp - replace the polling loop\n#include <dds/DdsDcpsInfrastructureC.h>\n\n// After creating DataReaders...\n\n// Create WaitSet and attach the close condition\nDDS::WaitSet_var ws = new DDS::WaitSet();\nDDS::GuardCondition_var close_cond = listener_servant->get_close_condition();\nDDS::ReturnCode_t ret = ws->attach_condition(close_cond.in());\nif (ret != DDS::RETCODE_OK) {\n  cerr << \"attach_condition failed\" << endl;\n  return 1;\n}\n\ncout << \"Subscriber: waiting for TRADING_CLOSED event\" << endl;\n\n// Wait efficiently (blocks until condition triggers or timeout)\nDDS::ConditionSeq active_conditions;\nDDS::Duration_t timeout = { DDS::DURATION_INFINITE_SEC, DDS::DURATION_INFINITE_NSEC };\n\nret = ws->wait(active_conditions, timeout);\n\nif (ret == DDS::RETCODE_OK) {\n  for (CORBA::ULong i = 0; i < active_conditions.length(); ++i) {\n    if (active_conditions[i] == close_cond.in()) {\n      cout << \"Received TRADING_CLOSED event; exiting...\" << endl;\n    }\n  }\n} else if (ret == DDS::RETCODE_TIMEOUT) {\n  cout << \"Wait timed out\" << endl;\n}\n\n// Cleanup\nws->detach_condition(close_cond.in());\n```\n\n**Benefits of this refactoring:**\n1. **Zero CPU usage while waiting** - blocks in kernel, no polling\n2. **Immediate response** - wakes up instantly when condition triggers\n3. **Scalable** - can attach multiple conditions to one WaitSet\n4. **Timeout support** - can set maximum wait duration\n5. **Standard DDS pattern** - portable across DDS implementations\n\n**Alternative: Use StatusCondition**\nFor data availability (instead of custom events):\n```cpp\nDDS::StatusCondition_var sc = reader->get_statuscondition();\nsc->set_enabled_statuses(DDS::DATA_AVAILABLE_STATUS);\nws->attach_condition(sc.in());\n```",
        "metadata": {
            "task_type": "refactoring",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/subscriber.cpp"
            ],
            "difficulty": "hard"
        }
    },
    {
        "instruction": "How do I implement a DataWriter that waits for matched subscriptions before publishing data?",
        "input": "I'm seeing that my published samples are sometimes lost because the subscriber hasn't connected yet. How can I ensure the DataWriter waits for at least one subscriber?",
        "output": "The Messenger_Imr example demonstrates the pattern for waiting for matched subscriptions:\n\n**Pattern 1: Poll for matched subscriptions (simple)**\n```cpp\n// From examples/DCPS/Messenger_Imr/Writer.cpp\nDDS::InstanceHandleSeq handles;\nwhile (true) {\n  writer_->get_matched_subscriptions(handles);\n  if (handles.length() > 0) {\n    break;  // At least one subscriber matched\n  }\n  ACE_OS::sleep(ACE_Time_Value(0, 200000));  // 200ms\n}\n\n// Now safe to write\nMessageDataWriter_var message_dw = MessageDataWriter::_narrow(writer_.in());\nmessage_dw->write(message, handle);\n```\n\n**Pattern 2: Use DataWriterListener (event-driven)**\n```cpp\nclass MyDataWriterListener : public virtual OpenDDS::DCPS::LocalObject<DDS::DataWriterListener> {\npublic:\n  MyDataWriterListener() : matched_(false), mutex_(), cv_() {}\n\n  void on_publication_matched(\n      DDS::DataWriter_ptr,\n      const DDS::PublicationMatchedStatus& status) override\n  {\n    ACE_Guard<ACE_Thread_Mutex> guard(mutex_);\n    if (status.current_count > 0) {\n      matched_ = true;\n      cv_.signal();\n    }\n  }\n\n  void wait_for_match() {\n    ACE_Guard<ACE_Thread_Mutex> guard(mutex_);\n    while (!matched_) {\n      cv_.wait(mutex_);\n    }\n  }\n\n  // Implement other required callbacks (can be empty)\n  void on_offered_deadline_missed(DDS::DataWriter_ptr, \n      const DDS::OfferedDeadlineMissedStatus&) override {}\n  void on_offered_incompatible_qos(DDS::DataWriter_ptr,\n      const DDS::OfferedIncompatibleQosStatus&) override {}\n  void on_liveliness_lost(DDS::DataWriter_ptr,\n      const DDS::LivelinessLostStatus&) override {}\n\nprivate:\n  bool matched_;\n  ACE_Thread_Mutex mutex_;\n  ACE_Condition_Thread_Mutex cv_;\n};\n\n// Usage:\nMyDataWriterListener* listener_impl = new MyDataWriterListener();\nDDS::DataWriterListener_var listener(listener_impl);\n\nDDS::DataWriter_var dw = pub->create_datawriter(\n    topic.in(), dw_qos, listener.in(),\n    DDS::PUBLICATION_MATCHED_STATUS);  // Only listen for this status\n\nlistener_impl->wait_for_match();  // Blocks until subscriber connects\n// Now write data...\n```\n\n**Pattern 3: Use WaitSet with StatusCondition**\n```cpp\n// Create DataWriter\nDDS::DataWriter_var writer = pub->create_datawriter(\n    topic.in(), dw_qos, DDS::DataWriterListener::_nil(),\n    OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n\n// Set up WaitSet with status condition\nDDS::StatusCondition_var status_cond = writer->get_statuscondition();\nstatus_cond->set_enabled_statuses(DDS::PUBLICATION_MATCHED_STATUS);\n\nDDS::WaitSet_var ws = new DDS::WaitSet();\nws->attach_condition(status_cond.in());\n\n// Wait for match\nDDS::ConditionSeq active;\nDDS::Duration_t timeout = {30, 0};  // 30 second timeout\n\nwhile (true) {\n  DDS::ReturnCode_t ret = ws->wait(active, timeout);\n  if (ret == DDS::RETCODE_TIMEOUT) {\n    cerr << \"Timeout waiting for subscriber\" << endl;\n    break;\n  }\n  \n  DDS::PublicationMatchedStatus pms;\n  writer->get_publication_matched_status(pms);\n  if (pms.current_count > 0) {\n    cout << \"Matched \" << pms.current_count << \" subscriber(s)\" << endl;\n    break;\n  }\n}\n\nws->detach_condition(status_cond.in());\n// Now write data...\n```\n\n**Also wait at shutdown to ensure delivery:**\n```cpp\n// After last write, wait for subscribers to disconnect\nwhile (true) {\n  writer_->get_matched_subscriptions(handles);\n  if (handles.length() == 0) {\n    break;  // All subscribers received data and disconnected\n  }\n  ACE_OS::sleep(1);\n}\n```",
        "metadata": {
            "task_type": "api_usage",
            "files": [
                "examples/DCPS/Messenger_Imr/Writer.cpp"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "What is the proper cleanup sequence for OpenDDS entities to avoid resource leaks and crashes?",
        "input": "My application sometimes crashes on shutdown. What's the correct order to clean up DDS entities?",
        "output": "Proper cleanup order is critical in OpenDDS. Follow this sequence (reverse of creation order):\n\n**Correct cleanup sequence:**\n```cpp\n// From examples/DCPS/IntroductionToOpenDDS/publisher.cpp\ntry {\n  // 1. Delete all entities created by the participant\n  if (!CORBA::is_nil(participant.in())) {\n    participant->delete_contained_entities();\n  }\n  \n  // 2. Delete the participant from the factory\n  if (!CORBA::is_nil(dpf.in())) {\n    dpf->delete_participant(participant.in());\n  }\n} catch (CORBA::Exception& e) {\n  cerr << \"Exception caught in cleanup.\" << endl << e << endl;\n}\n\n// 3. Shutdown the service participant (MUST be last)\nTheServiceParticipant->shutdown();\n```\n\n**What `delete_contained_entities()` does:**\n- Deletes all Publishers, Subscribers, Topics created by that participant\n- Each Publisher's DataWriters are deleted\n- Each Subscriber's DataReaders are deleted\n- Listeners are released\n- Recursive cleanup of the entire entity tree\n\n**Manual cleanup (if not using `delete_contained_entities()`):**\n```cpp\n// Must delete in correct order:\n\n// 1. Unregister instances (optional, for proper lifecycle)\nquote_dw->unregister_instance(quote, handle);\n\n// 2. Delete DataWriters before Publisher\npub->delete_datawriter(quote_dw.in());\n\n// 3. Delete DataReaders before Subscriber\nsub->delete_datareader(quote_dr.in());\n\n// 4. Delete Publisher and Subscriber before Topics\nparticipant->delete_publisher(pub.in());\nparticipant->delete_subscriber(sub.in());\n\n// 5. Delete Topics before Participant\nparticipant->delete_topic(quote_topic.in());\n\n// 6. Delete Participant\ndpf->delete_participant(participant.in());\n\n// 7. Shutdown service participant\nTheServiceParticipant->shutdown();\n```\n\n**Common crash causes and fixes:**\n\n**1. Listener outlives entity:**\n```cpp\n// BAD: Listener deleted before DataReader\nDDS::DataReaderListener_var listener(new MyListener());\nDDS::DataReader_var dr = sub->create_datareader(..., listener.in(), ...);\nlistener = DDS::DataReaderListener::_nil();  // Releases listener!\n// dr still holds raw pointer - CRASH when callback fires\n\n// GOOD: Let _var prevent premature deletion\nDDS::DataReaderListener_var listener(new MyListener());\n// listener _var prevents deletion until all references released\n```\n\n**2. Forgetting to shutdown:**\n```cpp\n// BAD: Missing shutdown causes resource leak\nreturn 0;\n\n// GOOD: Always call shutdown\nTheServiceParticipant->shutdown();\nreturn 0;\n```\n\n**3. Deleting entities out of order:**\n```cpp\n// BAD: Delete Topic while DataWriter still uses it\nparticipant->delete_topic(topic.in());\npub->delete_datawriter(writer.in());  // Topic gone - undefined behavior\n\n// GOOD: Delete writers first\npub->delete_datawriter(writer.in());\nparticipant->delete_topic(topic.in());\n```\n\n**4. Multiple participants in same process:**\n```cpp\n// When using multiple participants, delete ALL before shutdown\nparticipant1->delete_contained_entities();\ndpf->delete_participant(participant1.in());\n\nparticipant2->delete_contained_entities();\ndpf->delete_participant(participant2.in());\n\n// Only ONE shutdown call at the very end\nTheServiceParticipant->shutdown();\n```\n\n**Best practice: RAII wrapper**\n```cpp\nclass DDSGuard {\npublic:\n  DDSGuard(DDS::DomainParticipantFactory_var dpf, \n           DDS::DomainParticipant_var dp)\n    : dpf_(dpf), dp_(dp) {}\n  \n  ~DDSGuard() {\n    if (!CORBA::is_nil(dp_.in())) {\n      dp_->delete_contained_entities();\n      dpf_->delete_participant(dp_.in());\n    }\n    TheServiceParticipant->shutdown();\n  }\nprivate:\n  DDS::DomainParticipantFactory_var dpf_;\n  DDS::DomainParticipant_var dp_;\n};\n```",
        "metadata": {
            "task_type": "bug_fixing",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/publisher.cpp",
                "examples/DCPS/IntroductionToOpenDDS/subscriber.cpp"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "How do I set up an OpenDDS subscriber that filters content using a ContentFilteredTopic?",
        "input": "I want to receive only Quote samples where the value is above 1300. How do I create a ContentFilteredTopic in OpenDDS?",
        "output": "Here's how to create a ContentFilteredTopic in OpenDDS:\n\n**1. Create the base Topic first:**\n```cpp\n// Register type and create normal topic\nStockQuoter::QuoteTypeSupport_var quote_ts = new StockQuoter::QuoteTypeSupportImpl();\nquote_ts->register_type(participant.in(), \"Quote Type\");\n\nDDS::Topic_var quote_topic = participant->create_topic(\n    \"Stock Quotes\",\n    \"Quote Type\",\n    TOPIC_QOS_DEFAULT,\n    DDS::TopicListener::_nil(),\n    OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n```\n\n**2. Create ContentFilteredTopic with SQL-like filter:**\n```cpp\n// Filter expression - SQL-like WHERE clause\n// Parameters are referenced as %0, %1, etc.\nconst char* filter_expression = \"value > %0\";\n\n// Parameter values (as strings)\nDDS::StringSeq filter_params;\nfilter_params.length(1);\nfilter_params[0] = \"1300.0\";  // Filter for value > 1300\n\nDDS::ContentFilteredTopic_var filtered_topic = \n    participant->create_contentfilteredtopic(\n        \"High Value Quotes\",      // Unique name for filtered topic\n        quote_topic.in(),          // Base topic\n        filter_expression,         // SQL-like filter\n        filter_params);            // Parameter values\n\nif (CORBA::is_nil(filtered_topic.in())) {\n    cerr << \"create_contentfilteredtopic failed\" << endl;\n    return 1;\n}\n```\n\n**3. Create DataReader on the filtered topic:**\n```cpp\n// Use the filtered topic instead of the base topic\nDDS::DataReader_var quote_dr = sub->create_datareader(\n    filtered_topic.in(),  // ContentFilteredTopic, not Topic\n    DATAREADER_QOS_DEFAULT,\n    quote_listener.in(),\n    OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n```\n\n**4. Dynamically update filter parameters:**\n```cpp\n// Change threshold to 1500 at runtime\nDDS::StringSeq new_params;\nnew_params.length(1);\nnew_params[0] = \"1500.0\";\n\nDDS::ReturnCode_t ret = filtered_topic->set_expression_parameters(new_params);\nif (ret != DDS::RETCODE_OK) {\n    cerr << \"set_expression_parameters failed: \" << ret << endl;\n}\n```\n\n**Supported filter expressions:**\n\n```cpp\n// Comparison operators\n\"value > %0\"\n\"value >= %0 AND value <= %1\"  // Range\n\"ticker = %0\"                   // String equality\n\"ticker <> %0\"                  // Not equal\n\n// Logical operators\n\"value > %0 AND exchange = %1\"\n\"ticker = %0 OR ticker = %1\"\n\"NOT (value < %0)\"\n\n// BETWEEN and IN (with RTPS)\n\"value BETWEEN %0 AND %1\"\n\"ticker IN ('SPY', 'MDY', 'QQQ')\"\n\n// LIKE for pattern matching\n\"full_name LIKE 'S&P%'\"  // Starts with 'S&P'\n```\n\n**From ishapes example - rectangle filter:**\n```cpp\n// ShapesDialog.cpp uses position-based filtering\nconst char* filter = \"(x BETWEEN %0 AND %1) AND (y BETWEEN %2 AND %3)\";\n\nDDS::StringSeq params;\nparams.length(4);\nparams[0] = \"100\";  // x min\nparams[1] = \"200\";  // x max\nparams[2] = \"100\";  // y min  \nparams[3] = \"200\";  // y max\n\nDDS::ContentFilteredTopic_var cft = participant->create_contentfilteredtopic(\n    \"FilteredShape\", shape_topic.in(), filter, params);\n```\n\n**Cleanup:**\n```cpp\n// Delete in order: DataReader, then ContentFilteredTopic\nsub->delete_datareader(quote_dr.in());\nparticipant->delete_contentfilteredtopic(filtered_topic.in());\nparticipant->delete_topic(quote_topic.in());\n```\n\n**Important notes:**\n- ContentFilteredTopic inherits from TopicDescription, not Topic\n- Filtering happens on the subscriber side (not at publisher)\n- Filter expressions reference IDL field names directly\n- Parameters are always strings, converted to appropriate types\n- Cannot create a DataWriter on a ContentFilteredTopic",
        "metadata": {
            "task_type": "api_usage",
            "files": [
                "examples/DCPS/ishapes/ShapesDialog.cpp",
                "examples/DCPS/IntroductionToOpenDDS/StockQuoter.idl"
            ],
            "difficulty": "hard"
        }
    },
    {
        "instruction": "Navigate the OpenDDS codebase: where is the DataReaderImpl class defined and what are its key responsibilities?",
        "input": "I need to understand the internal implementation of DataReader in OpenDDS for debugging purposes.",
        "output": "The `DataReaderImpl` class is the core implementation of the DDS DataReader interface in OpenDDS.\n\n**Location:** [dds/DCPS/DataReaderImpl.h](dds/DCPS/DataReaderImpl.h)\n\n**Class declaration:**\n```cpp\n// dds/DCPS/DataReaderImpl.h\nnamespace OpenDDS {\nnamespace DCPS {\n\nclass OpenDDS_Dcps_Export DataReaderImpl\n  : public virtual LocalObject<DDS::DataReader>\n  , public virtual DataReaderCallbacks\n  , public virtual EntityImpl\n  , public virtual TransportClient\n  , public virtual TransportReceiveListener\n{\n```\n\n**Key inheritance:**\n- `LocalObject<DDS::DataReader>` - Implements DDS::DataReader interface\n- `DataReaderCallbacks` - Internal callback interface for associations\n- `EntityImpl` - Base entity functionality (enable, QoS, listener)\n- `TransportClient` - Transport layer integration\n- `TransportReceiveListener` - Receives data from transport\n\n**Key responsibilities:**\n\n**1. Sample Storage and Management:**\n```cpp\n// Manages received samples per instance\ntypedef OPENDDS_MAP(DDS::InstanceHandle_t, SubscriptionInstance_rch) SubscriptionInstanceMapType;\nSubscriptionInstanceMapType instances_;\n\n// Allocator for received data elements\nReceivedDataAllocator* rd_allocator_;\n```\n\n**2. Writer Association Tracking:**\n```cpp\n// Tracks DataWriters publishing to this reader\ntypedef OPENDDS_MAP_CMP(GUID_t, WriterInfo_rch, GUID_tKeyLessThan) WriterMapType;\nWriterMapType writers_;\n```\n\n**3. Statistics Collection:**\n```cpp\n// From WriterStats class in header\nclass WriterStats {\npublic:\n  void add_stat(const TimeDuration& delay);  // Latency tracking\n  LatencyStatistics get_stats() const;\n  void reset_stats();\n};\n```\n\n**4. Key methods to understand:**\n\n```cpp\n// Called by transport when data arrives\nvoid data_received(const ReceivedDataSample& sample);\n\n// Instance management\nDDS::InstanceHandle_t lookup_instance(const T& key);\nvoid store_instance_data(unique_ptr<DataSampleHeader>, ...);  \n\n// Read/Take operations (type-specific subclass provides typed version)\nvoid read_instance_i(...);\nvoid take_instance_i(...);\n\n// QoS and configuration\nvoid set_qos(const DDS::DataReaderQos& qos);\nDDS::DataReaderQos qos_;\n```\n\n**5. Type-specific template subclass:**\n\nActual typed readers use `DataReaderImpl_T<MessageType>`:\n```cpp\n// dds/DCPS/DataReaderImpl_T.h\ntemplate <typename MessageType>\nclass DataReaderImpl_T : public DataReaderImpl {\n  DDS::ReturnCode_t read_i(MessageSeq& data, \n                           DDS::SampleInfoSeq& info, ...);\n  DDS::ReturnCode_t take_next_sample(MessageType& data, \n                                     DDS::SampleInfo& info);\n};\n```\n\n**6. Important internal structures:**\n\n```cpp\n// SubscriptionInstance - one per DDS instance (key value)\n// Stores sample history for that instance\nclass SubscriptionInstance {\n  ReceivedDataElementList rcvd_samples_;\n  InstanceState instance_state_;\n};\n\n// WriterInfo - tracks per-writer state\nclass WriterInfo {\n  GUID_t writer_id_;\n  SequenceNumber last_seq_;\n  bool alive_;\n};\n```\n\n**Debugging tips:**\n- Set breakpoint in `data_received()` to see incoming samples\n- Check `instances_` map for sample storage issues\n- Examine `writers_` map for association problems\n- Enable `DCPSDebugLevel=5` to trace internal operations\n\n**Related files:**\n- [dds/DCPS/DataReaderImpl.cpp](dds/DCPS/DataReaderImpl.cpp) - Implementation\n- [dds/DCPS/SubscriptionInstance.h](dds/DCPS/SubscriptionInstance.h) - Instance data\n- [dds/DCPS/WriterInfo.h](dds/DCPS/WriterInfo.h) - Writer tracking",
        "metadata": {
            "task_type": "code_explanation",
            "files": [
                "dds/DCPS/DataReaderImpl.h"
            ],
            "difficulty": "hard"
        }
    },
    {
        "instruction": "Improve the error handling in this DistributedContent example to provide better diagnostics.",
        "input": "File: examples/DCPS/DistributedContent/FileInfoListener.cpp\n\n```cpp\nvoid FileInfoListener::on_data_available (::DDS::DataReader_ptr reader)\n{\n  try {\n    DistributedContent::FileDiffDataReader_var fileinfo_dr =\n      DistributedContent::FileDiffDataReader::_narrow(reader);\n    if (CORBA::is_nil (fileinfo_dr.in ())) {\n      ACE_ERROR((LM_ERROR, \"ERROR: FileInfoListener::on_data_available() _narrow failed.\\n\"));\n      return;\n    }\n\n    DistributedContent::FileDiff diff;\n    DDS::SampleInfo si ;\n    DDS::ReturnCode_t status = fileinfo_dr->take_next_sample(diff, si) ;\n\n    if (status == DDS::RETCODE_OK) {\n      if (0 != change_monitor_) {\n        change_monitor_->receive_diff(diff);\n      } else {\n        ACE_DEBUG((LM_DEBUG,\n          \"FileInfoListener::on_data_available() no change_monitor_ defined\\n\"));\n      }\n    } else if (status == DDS::RETCODE_NO_DATA) {\n      ACE_ERROR((LM_ERROR,\n        \"ERROR: FileInfoListener::on_data_available() received DDS::RETCODE_NO_DATA!\"));\n    } else {\n      ACE_ERROR((LM_ERROR,\n        \"ERROR: FileInfoListener::on_data_available() read Message: Error: %d\\n\",\n        status));\n    }\n  } catch (CORBA::Exception&) {\n    ACE_ERROR((LM_ERROR,\n      \"ERROR: FileInfoListener::on_data_available() Exception caught in read\\n\"));\n  }\n}\n```\n\nThe error messages are vague and don't help diagnose issues.",
        "output": "Here's an improved version with comprehensive diagnostics:\n\n```cpp\n#include \"FileInfoListener.h\"\n#include \"AbstractionLayer.h\"\n#include \"FileInfoC.h\"\n#include \"FileInfoTypeSupportC.h\"\n#include <dds/DCPS/GuidConverter.h>  // For readable GUIDs\n\nnamespace {\n  // Helper to convert return codes to strings\n  const char* retcode_to_string(DDS::ReturnCode_t rc) {\n    switch (rc) {\n      case DDS::RETCODE_OK: return \"RETCODE_OK\";\n      case DDS::RETCODE_NO_DATA: return \"RETCODE_NO_DATA\";\n      case DDS::RETCODE_ERROR: return \"RETCODE_ERROR\";\n      case DDS::RETCODE_BAD_PARAMETER: return \"RETCODE_BAD_PARAMETER\";\n      case DDS::RETCODE_UNSUPPORTED: return \"RETCODE_UNSUPPORTED\";\n      case DDS::RETCODE_ALREADY_DELETED: return \"RETCODE_ALREADY_DELETED\";\n      case DDS::RETCODE_OUT_OF_RESOURCES: return \"RETCODE_OUT_OF_RESOURCES\";\n      case DDS::RETCODE_NOT_ENABLED: return \"RETCODE_NOT_ENABLED\";\n      case DDS::RETCODE_PRECONDITION_NOT_MET: return \"RETCODE_PRECONDITION_NOT_MET\";\n      case DDS::RETCODE_TIMEOUT: return \"RETCODE_TIMEOUT\";\n      case DDS::RETCODE_ILLEGAL_OPERATION: return \"RETCODE_ILLEGAL_OPERATION\";\n      default: return \"UNKNOWN_RETCODE\";\n    }\n  }\n\n  const char* instance_state_to_string(DDS::InstanceStateKind state) {\n    switch (state) {\n      case DDS::ALIVE_INSTANCE_STATE: return \"ALIVE\";\n      case DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE: return \"DISPOSED\";\n      case DDS::NOT_ALIVE_NO_WRITERS_INSTANCE_STATE: return \"NO_WRITERS\";\n      default: return \"UNKNOWN\";\n    }\n  }\n}\n\nvoid FileInfoListener::on_data_available(::DDS::DataReader_ptr reader)\n{\n  ACE_DEBUG((LM_DEBUG, \"(%P|%t) FileInfoListener::on_data_available() called\\n\"));\n  \n  try {\n    DistributedContent::FileDiffDataReader_var fileinfo_dr =\n      DistributedContent::FileDiffDataReader::_narrow(reader);\n    \n    if (CORBA::is_nil(fileinfo_dr.in())) {\n      ACE_ERROR((LM_ERROR,\n        \"(%P|%t) ERROR: FileInfoListener::on_data_available() \"\n        \"_narrow failed - reader may be wrong type or deleted.\\n\"\n        \"  Expected type: DistributedContent::FileDiffDataReader\\n\"));\n      return;\n    }\n\n    int samples_processed = 0;\n    int invalid_samples = 0;\n    \n    // Loop to process all available samples\n    while (true) {\n      DistributedContent::FileDiff diff;\n      DDS::SampleInfo si;\n      DDS::ReturnCode_t status = fileinfo_dr->take_next_sample(diff, si);\n\n      if (status == DDS::RETCODE_NO_DATA) {\n        ACE_DEBUG((LM_DEBUG,\n          \"(%P|%t) FileInfoListener: Processed %d samples (%d invalid)\\n\",\n          samples_processed, invalid_samples));\n        break;\n      }\n      \n      if (status != DDS::RETCODE_OK) {\n        ACE_ERROR((LM_ERROR,\n          \"(%P|%t) ERROR: FileInfoListener::on_data_available() \"\n          \"take_next_sample failed\\n\"\n          \"  Return code: %C (%d)\\n\"\n          \"  Possible causes:\\n\"\n          \"    - DataReader has been deleted\\n\"\n          \"    - Internal resource exhaustion\\n\",\n          retcode_to_string(status), status));\n        break;\n      }\n\n      // Log SampleInfo for diagnostics\n      ACE_DEBUG((LM_DEBUG,\n        \"(%P|%t) FileInfoListener: Received sample\\n\"\n        \"  valid_data: %C\\n\"\n        \"  instance_state: %C\\n\"\n        \"  sample_rank: %d\\n\"\n        \"  generation_rank: %d\\n\",\n        si.valid_data ? \"true\" : \"false\",\n        instance_state_to_string(si.instance_state),\n        si.sample_rank,\n        si.generation_rank));\n\n      if (!si.valid_data) {\n        ++invalid_samples;\n        // Handle lifecycle events\n        ACE_DEBUG((LM_DEBUG,\n          \"(%P|%t) FileInfoListener: Instance state change (no data)\\n\"\n          \"  instance_handle: 0x%x\\n\"\n          \"  instance_state: %C\\n\",\n          si.instance_handle,\n          instance_state_to_string(si.instance_state)));\n        \n        if (si.instance_state == DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE) {\n          // Notify application of disposal if needed\n          if (change_monitor_) {\n            // change_monitor_->handle_dispose(si.instance_handle);\n          }\n        }\n        continue;\n      }\n\n      ++samples_processed;\n      \n      // Log received data details\n      ACE_DEBUG((LM_DEBUG,\n        \"(%P|%t) FileInfoListener: Valid FileDiff received\\n\"\n        \"  file_id: %d\\n\"\n        \"  filename: %C\\n\"\n        \"  change_source: %C\\n\"\n        \"  version: %d -> %d\\n\"\n        \"  diff_size: %d bytes\\n\",\n        diff.file_id,\n        diff.filename.in(),\n        diff.change_source.in(),\n        diff.previous_version,\n        diff.new_version,\n        diff.difference.length()));\n\n      if (change_monitor_ != 0) {\n        change_monitor_->receive_diff(diff);\n      } else {\n        ACE_ERROR((LM_WARNING,\n          \"(%P|%t) WARNING: FileInfoListener::on_data_available() \"\n          \"change_monitor_ is null - sample will be discarded.\\n\"\n          \"  Ensure AbstractionLayer is properly initialized.\\n\"));\n      }\n    }\n    \n  } catch (const CORBA::BAD_PARAM& e) {\n    ACE_ERROR((LM_ERROR,\n      \"(%P|%t) ERROR: FileInfoListener CORBA::BAD_PARAM exception\\n\"\n      \"  Info: %C\\n\"\n      \"  This usually indicates type mismatch in _narrow()\\n\",\n      e._info().c_str()));\n  } catch (const CORBA::Exception& e) {\n    ACE_ERROR((LM_ERROR,\n      \"(%P|%t) ERROR: FileInfoListener CORBA::Exception\\n\"\n      \"  Type: %C\\n\"\n      \"  Info: %C\\n\",\n      e._name(), e._info().c_str()));\n  } catch (const std::exception& e) {\n    ACE_ERROR((LM_ERROR,\n      \"(%P|%t) ERROR: FileInfoListener std::exception: %C\\n\",\n      e.what()));\n  } catch (...) {\n    ACE_ERROR((LM_ERROR,\n      \"(%P|%t) ERROR: FileInfoListener unknown exception\\n\"));\n  }\n}\n```\n\n**Key improvements:**\n1. **Process all samples** - Loop until `RETCODE_NO_DATA`\n2. **Check `valid_data`** - Handle dispose/unregister events\n3. **Descriptive error messages** - Include return code names and possible causes\n4. **Sample info logging** - Shows instance state, ranks for debugging\n5. **Specific exception handling** - Different catch blocks for different exception types\n6. **Thread/process IDs** - `(%P|%t)` in log messages for multi-process debugging\n7. **Data content logging** - Shows what was received for verification",
        "metadata": {
            "task_type": "documentation_improvement",
            "files": [
                "examples/DCPS/DistributedContent/FileInfoListener.cpp",
                "examples/DCPS/DistributedContent/FileInfo.idl"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "How do I define multiple keys in an OpenDDS IDL struct and what effect does it have?",
        "input": "I want to track messages by both sender and subject. How do I define a composite key?",
        "output": "In OpenDDS, you can define multiple keys by applying the `@key` annotation to multiple fields:\n\n**IDL Definition:**\n```idl\nmodule Messaging {\n  @topic\n  struct Message {\n    @key string sender;      // First key field\n    @key string subject;     // Second key field\n    long sequence_number;\n    string body;\n    long long timestamp;\n  };\n};\n```\n\n**Effect of composite keys:**\n\nWith the above definition, DDS Instances are identified by the combination of `(sender, subject)`:\n\n| sender | subject | Instance |\n|--------|---------|----------|\n| \"Alice\" | \"Weather\" | Instance 1 |\n| \"Alice\" | \"Sports\" | Instance 2 |\n| \"Bob\" | \"Weather\" | Instance 3 |\n| \"Bob\" | \"Sports\" | Instance 4 |\n\n**Code usage:**\n```cpp\n// Each unique (sender, subject) combination is a separate instance\nMessaging::Message msg1;\nmsg1.sender = \"Alice\";\nmsg1.subject = \"Weather\";\nmsg1.body = \"Sunny today\";\nDDS::InstanceHandle_t h1 = writer->register_instance(msg1);\n\nMessaging::Message msg2;\nmsg2.sender = \"Alice\";\nmsg2.subject = \"Sports\";  // Different subject = different instance\nmsg2.body = \"Game tonight\";\nDDS::InstanceHandle_t h2 = writer->register_instance(msg2);\n\n// h1 != h2 because (Alice, Weather) != (Alice, Sports)\n\n// Update same instance (Alice, Weather)\nmsg1.body = \"Rain expected\";\nmsg1.sequence_number = 2;\nwriter->write(msg1, h1);  // Updates Instance 1\n```\n\n**QoS implications:**\n\n**HISTORY QoS:**\n```cpp\nDDS::DataReaderQos dr_qos;\nsub->get_default_datareader_qos(dr_qos);\ndr_qos.history.kind = DDS::KEEP_LAST_HISTORY_QOS;\ndr_qos.history.depth = 5;  // Keep last 5 samples PER INSTANCE\n```\nWith composite key, each `(sender, subject)` pair keeps its own 5-sample history.\n\n**OWNERSHIP QoS:**\nExclusive ownership is determined per-instance. Different writers can own different instances.\n\n**DEADLINE QoS:**\nDeadline monitoring is per-instance. Each `(sender, subject)` must receive updates within the deadline.\n\n**Nested struct keys:**\n```idl\nstruct SenderInfo {\n  @key string name;\n  @key string department;\n};\n\n@topic\nstruct Message {\n  @key SenderInfo sender;  // Both name and department become keys\n  string subject;\n  string body;\n};\n// Instance key is (sender.name, sender.department)\n```\n\n**Comparison with StockQuoter example:**\n```idl\n// From StockQuoter.idl - single key\n@topic\nstruct Quote {\n  @key string ticker;  // One key: each ticker is an instance\n  string exchange;\n  double value;\n};\n// Instances: \"SPY\", \"MDY\", \"QQQ\", etc.\n```\n\n**Best practices:**\n1. Choose keys that naturally identify your data instances\n2. Keep keys immutable after instance registration\n3. Consider key cardinality - too many instances can impact memory\n4. Use `@key(FALSE)` to explicitly exclude fields in nested structs",
        "metadata": {
            "task_type": "code_explanation",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/StockQuoter.idl",
                "examples/DCPS/Messenger_Imr/Messenger.idl"
            ],
            "difficulty": "easy"
        }
    },
    {
        "instruction": "Add proper instance lifecycle management (dispose/unregister) to this publisher code.",
        "input": "File: examples/DCPS/IntroductionToOpenDDS/publisher.cpp (excerpt)\n\n```cpp\n// Register instances\nStockQuoter::Quote spy;\nspy.ticker = CORBA::string_dup(\"SPY\");\nDDS::InstanceHandle_t spy_handle = quote_dw->register_instance(spy);\n\nStockQuoter::Quote mdy;\nmdy.ticker = CORBA::string_dup(\"MDY\");\nDDS::InstanceHandle_t mdy_handle = quote_dw->register_instance(mdy);\n\n// Publish quotes...\nfor (int i = 0; i < 20; ++i) {\n  // ... write spy and mdy quotes\n}\n\n// Current cleanup - just exits\ncout << \"Exiting...\" << endl;\n```\n\nThe publisher doesn't properly dispose instances when done, leaving subscribers uncertain about data lifecycle.",
        "output": "Here's the improved publisher with proper instance lifecycle management:\n\n```cpp\n// Register instances\nStockQuoter::Quote spy;\nspy.ticker = CORBA::string_dup(\"SPY\");\nDDS::InstanceHandle_t spy_handle = quote_dw->register_instance(spy);\n\nStockQuoter::Quote mdy;\nmdy.ticker = CORBA::string_dup(\"MDY\");\nDDS::InstanceHandle_t mdy_handle = quote_dw->register_instance(mdy);\n\n// Track registration for cleanup\nACE_DEBUG((LM_DEBUG, \"Registered instances: SPY (handle=%d), MDY (handle=%d)\\n\",\n           spy_handle, mdy_handle));\n\n// Publish quotes...\nfor (int i = 0; i < 20; ++i) {\n  StockQuoter::Quote spy_quote;\n  spy_quote.exchange = STOCK_EXCHANGE_NAME;\n  spy_quote.ticker = CORBA::string_dup(\"SPY\");\n  spy_quote.full_name = CORBA::string_dup(\"S&P Depository Receipts\");\n  spy_quote.value = 1200.0 + 10.0*i;\n  spy_quote.timestamp = get_timestamp();\n\n  DDS::ReturnCode_t ret = quote_dw->write(spy_quote, spy_handle);\n  if (ret != DDS::RETCODE_OK) {\n    ACE_ERROR((LM_ERROR, \"ERROR: SPY write returned %d.\\n\", ret));\n  }\n\n  ACE_OS::sleep(quarterSecond);\n\n  StockQuoter::Quote mdy_quote;\n  mdy_quote.exchange = STOCK_EXCHANGE_NAME;\n  mdy_quote.ticker = CORBA::string_dup(\"MDY\");\n  mdy_quote.full_name = CORBA::string_dup(\"S&P Midcap Depository Receipts\");\n  mdy_quote.value = 1400.0 + 10.0*i;\n  mdy_quote.timestamp = get_timestamp();\n\n  ret = quote_dw->write(mdy_quote, mdy_handle);\n  if (ret != DDS::RETCODE_OK) {\n    ACE_ERROR((LM_ERROR, \"ERROR: MDY write returned %d.\\n\", ret));\n  }\n\n  ACE_OS::sleep(quarterSecond);\n}\n\n// ============================================================\n// PROPER INSTANCE LIFECYCLE MANAGEMENT\n// ============================================================\n\n// Option 1: DISPOSE - tells subscribers \"this data is no longer valid\"\n// Use when the real-world entity no longer exists or data is stale\ncout << \"Disposing instances...\" << endl;\n\nDDS::ReturnCode_t ret;\n\n// Dispose SPY - subscribers see instance_state = NOT_ALIVE_DISPOSED\nret = quote_dw->dispose(spy, spy_handle);\nif (ret != DDS::RETCODE_OK) {\n  ACE_ERROR((LM_ERROR, \"ERROR: dispose(SPY) returned %d\\n\", ret));\n} else {\n  ACE_DEBUG((LM_DEBUG, \"Disposed SPY instance\\n\"));\n}\n\n// Dispose MDY\nret = quote_dw->dispose(mdy, mdy_handle);\nif (ret != DDS::RETCODE_OK) {\n  ACE_ERROR((LM_ERROR, \"ERROR: dispose(MDY) returned %d\\n\", ret));\n} else {\n  ACE_DEBUG((LM_DEBUG, \"Disposed MDY instance\\n\"));\n}\n\n// Option 2: UNREGISTER - tells subscribers \"I'm done writing this instance\"\n// Use when this writer is done but instance may still be valid from other writers\n// Subscribers see instance_state = NOT_ALIVE_NO_WRITERS (if no other writers)\n\n// ret = quote_dw->unregister_instance(spy, spy_handle);\n// ret = quote_dw->unregister_instance(mdy, mdy_handle);\n\n// Option 3: Combined - dispose then unregister for complete cleanup\n// quote_dw->dispose(spy, spy_handle);\n// quote_dw->unregister_instance(spy, spy_handle);\n\n// ============================================================\n// Wait for subscribers to receive disposal notifications\n// ============================================================\ncout << \"Waiting for subscribers to acknowledge...\" << endl;\n\n// Wait for reliable delivery if using RELIABLE QoS\nDDS::Duration_t wait_timeout = {10, 0};  // 10 seconds\nret = quote_dw->wait_for_acknowledgments(wait_timeout);\nif (ret == DDS::RETCODE_OK) {\n  ACE_DEBUG((LM_DEBUG, \"All samples acknowledged\\n\"));\n} else if (ret == DDS::RETCODE_TIMEOUT) {\n  ACE_ERROR((LM_WARNING, \"WARNING: Timeout waiting for acknowledgments\\n\"));\n}\n\n// ============================================================\n// Wait for subscribers to disconnect (optional but courteous)\n// ============================================================\nDDS::InstanceHandleSeq handles;\nint wait_count = 0;\nwhile (wait_count < 10) {  // Max 10 seconds\n  quote_dw->get_matched_subscriptions(handles);\n  if (handles.length() == 0) {\n    ACE_DEBUG((LM_DEBUG, \"All subscribers disconnected\\n\"));\n    break;\n  }\n  ACE_DEBUG((LM_DEBUG, \"Waiting for %d subscriber(s) to disconnect...\\n\",\n             handles.length()));\n  ACE_OS::sleep(1);\n  ++wait_count;\n}\n\ncout << \"Exiting...\" << endl;\n```\n\n**Subscriber-side handling:**\n```cpp\nvoid QuoteDataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader)\n{\n  // ...\n  while (true) {\n    DDS::ReturnCode_t status = quote_dr->take_next_sample(quote, si);\n    \n    if (status == DDS::RETCODE_NO_DATA) break;\n    \n    if (si.valid_data) {\n      // Normal data sample\n      process_quote(quote);\n    } else {\n      // Lifecycle event - no data payload\n      if (si.instance_state == DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE) {\n        cout << \"Quote instance disposed by publisher\" << endl;\n        // Clean up local resources for this instance\n      } else if (si.instance_state == DDS::NOT_ALIVE_NO_WRITERS_INSTANCE_STATE) {\n        cout << \"Quote instance has no more writers\" << endl;\n        // May want to mark data as stale\n      }\n    }\n  }\n}\n```\n\n**Key concepts:**\n- **dispose()**: Instance data is no longer valid (entity removed)\n- **unregister_instance()**: This writer is done (other writers may continue)\n- **wait_for_acknowledgments()**: Ensure reliable delivery completed\n- Subscribers receive lifecycle changes via `SampleInfo.instance_state`",
        "metadata": {
            "task_type": "refactoring",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/publisher.cpp"
            ],
            "difficulty": "medium"
        }
    },
    {
        "instruction": "What are the differences between RTPS discovery and InfoRepo discovery in OpenDDS, and when should I use each?",
        "input": "I'm setting up a new OpenDDS deployment and need to choose a discovery mechanism.",
        "output": "OpenDDS supports two primary discovery mechanisms with different characteristics:\n\n## **InfoRepo Discovery (Centralized)**\n\n**Configuration:**\n```ini\n[common]\nDCPSInfoRepo=corbaloc::localhost:12345/DCPSInfoRepo\n```\n\n**Architecture:**\n- Centralized server (`DCPSInfoRepo` process) maintains all discovery data\n- Participants register with InfoRepo\n- InfoRepo brokers associations between writers and readers\n- Uses CORBA/IIOP for communication\n\n**Advantages:**\n- Works in all network topologies\n- Single point for monitoring/debugging\n- Supports persistent durability (with `-file` option)\n- Works across subnets without multicast\n- Lower network overhead for static deployments\n\n**Disadvantages:**\n- Single point of failure (unless federated)\n- Requires starting InfoRepo before participants\n- Extra process to manage\n- Latency for discovery through central server\n\n**When to use:**\n- Enterprise environments with network restrictions\n- No multicast available\n- Need centralized control/monitoring\n- Persistent topic/participant data required\n- Legacy deployments\n\n---\n\n## **RTPS Discovery (Peer-to-Peer)**\n\n**Configuration:**\n```ini\n[common]\nDCPSDefaultDiscovery=DEFAULT_RTPS\n\n# Optional: customize RTPS discovery\n[rtps_discovery/MyDiscovery]\nResendPeriod=5\nSedpMulticast=1\n```\n\n**Architecture:**\n- Decentralized, peer-to-peer discovery\n- Uses RTPS SPDP (Simple Participant Discovery Protocol)\n- Uses RTPS SEDP (Simple Endpoint Discovery Protocol)\n- Multicast for participant discovery (configurable)\n- Unicast for endpoint discovery\n\n**Advantages:**\n- No central server required\n- No single point of failure\n- OMG DDS-RTPS standard compliant\n- Interoperable with other DDS implementations\n- Lower latency for discovery\n- Self-healing (participants auto-discover on join)\n\n**Disadvantages:**\n- Requires multicast (for default config) or peer lists\n- More network traffic for large systems\n- Each participant maintains discovery state\n- More complex debugging\n\n**When to use:**\n- Distributed/embedded systems\n- Need DDS interoperability\n- Dynamic environments with frequent join/leave\n- No central infrastructure available\n- Cloud-native deployments\n\n---\n\n## **Configuration Examples**\n\n**RTPS with explicit peer list (no multicast):**\n```ini\n[common]\nDCPSDefaultDiscovery=MyDiscovery\n\n[rtps_discovery/MyDiscovery]\nSpdpSendAddrs=192.168.1.10:7400,192.168.1.11:7400\nSedpMulticast=0\n```\n\n**RTPS with custom ports:**\n```ini\n[rtps_discovery/MyDiscovery]\nPB=7400            # Port base\nDG=250             # Domain gain (port offset per domain)\nPG=2               # Participant gain\nD0=0               # Discovery multicast offset\nD1=10              # Discovery unicast offset\n```\n\n**InfoRepo with persistence:**\n```bash\nDCPSInfoRepo -o repo.ior -file persistent_data\n```\n\n---\n\n## **Hybrid Approach**\n\nYou can use different discovery per domain:\n```ini\n[domain/42]\nDiscoveryConfig=MyRTPS\n\n[domain/100]\nDiscoveryConfig=MyInfoRepo\n\n[rtps_discovery/MyRTPS]\n# RTPS settings...\n\n[repository/MyInfoRepo]\nRepositoryIor=corbaloc::server:12345/DCPSInfoRepo\n```\n\n---\n\n## **Decision Matrix**\n\n| Requirement | InfoRepo | RTPS |\n|-------------|----------|------|\n| No multicast |  | Needs peer list |\n| DDS interop |  |  |\n| Central control |  |  |\n| No extra processes |  |  |\n| Fault tolerance | Needs federation |  |\n| Dynamic membership | Slower |  |\n| Debugging | Easier | Harder |\n\n**Recommendation:** Use RTPS for new deployments unless you have specific requirements for centralized control or multicast restrictions.",
        "metadata": {
            "task_type": "build_configuration",
            "files": [
                "examples/DCPS/IntroductionToOpenDDS/dds_tcp_conf.ini",
                "docs/devguide/run_time_configuration.rst"
            ],
            "difficulty": "medium"
        }
    }
]